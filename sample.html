<!DOCTYPE html>
<html>
<head>
  <title>Basic Bust-a-Move / Puzzle Bobble / Bubble Shooter HTML Game</title>
  <meta charset="UTF-8">
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    body {
      background: #0c0c0c;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>
<body>
  <canvas width="271" height="392" id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const context = canvas.getContext('2d');

    const grid = 32;
    const level1 = [
      ['R','R','Y','Y','B','B','G','G'],
      ['R','R','Y','Y','B','B','G'],
      ['B','B','G','G','R','R','Y','Y'],
      ['B','G','G','R','R','Y','Y']
    ];
    const colorMap = { 'R': 'red', 'G': 'green', 'B': 'blue', 'Y': 'yellow' };
    const colors = Object.values(colorMap);
    const bubbleGap = 1;
    const wallSize = 4;
    const bubbles = [];
    let particles = [];

    function degToRad(deg) { return (deg * Math.PI) / 180; }
    function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function getDistance(obj1, obj2) { return Math.sqrt(Math.pow(obj1.x - obj2.x, 2) + Math.pow(obj1.y - obj2.y, 2)); }
    function collides(obj1, obj2) { return getDistance(obj1, obj2) < obj1.radius + obj2.radius; }

    function createBubble(x, y, color) {
      const row = Math.floor(y / grid);
      const col = Math.floor(x / grid);
      const startX = row % 2 === 0 ? 0 : 0.5 * grid;
      const center = grid / 2;
      bubbles.push({
        x: wallSize + (grid + bubbleGap) * col + startX + center,
        y: wallSize + (grid + bubbleGap - 4) * row + center,
        radius: grid / 2,
        color: color,
        active: color ? true : false
      });
    }

    const curBubblePos = { x: canvas.width / 2, y: canvas.height - grid * 1.5 };
    const curBubble = { x: curBubblePos.x, y: curBubblePos.y, color: 'red', radius: grid / 2, speed: 8, dx: 0, dy: 0 };
    let shootDeg = 0;
    const minDeg = degToRad(-60);
    const maxDeg = degToRad(60);

    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < (row % 2 === 0 ? 8 : 7); col++) {
        const color = level1[row]?.[col];
        createBubble(col * grid, row * grid, colorMap[color]);
      }
    }

    function getNewBubble() {
      curBubble.x = curBubblePos.x;
      curBubble.y = curBubblePos.y;
      curBubble.dx = curBubble.dy = 0;
      const randInt = getRandomInt(0, colors.length - 1);
      curBubble.color = colors[randInt];
    }

    function handleCollision(bubble) {
      bubble.color = curBubble.color;
      bubble.active = true;
      getNewBubble();
      // Implement removeMatch and dropFloatingBubbles functions as needed
    }

    function loop() {
      requestAnimationFrame(loop);
      context.clearRect(0,0,canvas.width,canvas.height);
      
      shootDeg = Math.max(minDeg, Math.min(maxDeg, shootDeg));

      curBubble.x += curBubble.dx;
      curBubble.y += curBubble.dy;

      if (curBubble.x - grid / 2 < wallSize) { curBubble.dx *= -1; }
      else if (curBubble.x + grid / 2 > canvas.width - wallSize) { curBubble.dx *= -1; }
      if (curBubble.y - grid / 2 < wallSize) {
        handleCollision(getClosestBubble(curBubble));
      }

      particles.forEach(particle => { particle.y += 8; });
      particles = particles.filter(particle => particle.y < canvas.height - grid / 2);

      context.fillStyle = 'lightgrey';
      context.fillRect(0, 0, canvas.width, wallSize);
      context.fillRect(0, 0, wallSize, canvas.height);
      context.fillRect(canvas.width - wallSize, 0, wallSize, canvas.height);

      context.save();
      context.translate(curBubblePos.x, curBubblePos.y);
      context.rotate(shootDeg);
      context.translate(0, -grid / 2 * 4.5);
      context.strokeStyle = 'white';
      context.lineWidth = 2;
      context.beginPath();
      context.moveTo(0, 0);
      context.lineTo(0, grid * 2);
      context.moveTo(0, 0);
      context.lineTo(-10, grid * 0.4);
      context.moveTo(0, 0);
      context.lineTo(10, grid * 0.4);
      context.stroke();
      context.restore();

      context.fillStyle = curBubble.color;
      context.beginPath();
      context.arc(curBubble.x, curBubble.y, curBubble.radius, 0, 2 * Math.PI);
      context.fill();
    }

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touchX = e.touches[0].clientX - canvas.offsetLeft;
      shootDeg = Math.atan2(touchX - curBubblePos.x, canvas.height - curBubblePos.y);
    });

    canvas.addEventListener('touchend', () => {
      if (curBubble.dx === 0 && curBubble.dy === 0) {
        curBubble.dx = Math.sin(shootDeg) * curBubble.speed;
        curBubble.dy = -Math.cos(shootDeg) * curBubble.speed;
      }
    });

    requestAnimationFrame(loop);
  </script>
</body>
</html>
